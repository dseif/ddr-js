(function (window) {    window.DDRJS = function (elem) {        var _that = this,            _resources = {                receptors: {}            },            _loader = new PIXI.loaders.Loader();        var _app;        function loadAssets(assets, cb) {            assets.forEach(function (asset) {                _loader.add(asset.name, asset.path);            });            if (cb && typeof cb === 'function') {                _loader.once('complete', cb);            }            _loader.load();        }        // Once resources have loaded we need to setup each receptor add it to the stage        /*         * TODO: This needs to be abstracted more. This function is doing a lot of work         * for two separate use cases. This likely means the `receptor` specific logic should be removed         * and put in the calling function. This should be responsible for setting up rows of arrows         * regardless of where they're used         */        function setupReceptors(loader, resources, container, inputs, areReceptors, offsetY) {            var receptor = resources.receptor;            var texture,                receptorContainer,                receptorLeft,                receptorUp,                receptorDown,                receptorRight,                rotationsAtIdx = [0, 270, 90, 180];            if (!receptor) {                return;            }            texture = receptor.texture;            receptorContainer = container;            // Creates sprites for each receptor            if (+inputs[0]) {                receptorLeft = new PIXI.Sprite.from(texture);            }            if (+inputs[1]) {                receptorDown = new PIXI.Sprite.from(texture);            }            if (+inputs[2]) {                receptorUp = new PIXI.Sprite.from(texture);            }            if (+inputs[3]) {                receptorRight = new PIXI.Sprite.from(texture);            }            // Perform common setup for each receptor            [receptorLeft, receptorDown, receptorUp, receptorRight].forEach(function (receptor, idx) {                if (!receptor) {                    return;                }                receptor.anchor.set(0.5);                receptor.x = (receptor.width + 25) * idx;                if (offsetY) {                    receptor.y = offsetY;                }                receptor.rotation = _that.utils.degressToRadians(rotationsAtIdx[idx]);            });            // This is disgusting...            if (areReceptors) {                _resources.receptors.receptorLeft = receptorLeft;                _resources.receptors.receptorUp = receptorUp;                _resources.receptors.receptorDown = receptorDown;                _resources.receptors.receptorRight = receptorRight;            }            // Add receptors to container            if (receptorLeft) {                receptorContainer.addChild(receptorLeft);            }            if (receptorDown) {                receptorContainer.addChild(receptorDown);            }            if (receptorUp) {                receptorContainer.addChild(receptorUp);            }            if (receptorRight) {                receptorContainer.addChild(receptorRight);            }        }        function setup (cb) {            receptorContainerWidth = 500,            _app = new PIXI.Application(_that.SCENE_WIDTH, _that.SCENE_HEIGHT, {                backgroundColor : 000000            });            // Create container to hold receptors            receptorContainer = new PIXI.Container();            receptorContainer.x = (_that.SCENE_WIDTH - receptorContainerWidth) / 2;            receptorContainer.y = 75;            _resources.receptors.container = receptorContainer;            // Put the scene in the DOM            elem.appendChild(_app.view);            loadAssets([{                name: 'receptor',                path: 'assets/receptor.png'            }], function (loader, resources) {                setupReceptors(loader, resources, receptorContainer, [1, 1, 1, 1], true);                _app.stage.addChild(receptorContainer);                if (cb && typeof cb === 'function') {                    cb();                }            });        }        function loadStepFile(cb) {            var request = new XMLHttpRequest();            function parseResponse(data) {                var formatted = {                    meta: {},                    measures: []                },                measure = [];                data.split('\n').forEach(function (row) {                    var metaInfo;                    // Don't do anything with an empty row                    if (row === '' || row === '\n' || row === '\r') {                        return;                    }                    // Any row that begins with a '#' is meta info                    if (row.charAt(0) === '#') {                        // Strip unwanted characters                        row = row.substring(1, row.length - 1);                        // Separate the key/val                        metaInfo = row.split(':');                        formatted.meta[metaInfo[0]] = metaInfo[1] || '';                        return;                    }                    // Skip crap I don't understand                    if (row === ',\r' || +row >= 0) {                        // If we get to this point we know we're going to be parsing the inputs                        // Split measures on commas                        if (row !== ',\r') {                            measure.push(row);                            return;                        }                        // If this row === ',' we want to push the current measure into the formatted array                        // and reset the current measure.                        formatted.measures.push(measure);                        measure = [];                    }                });                return formatted;            }            request.onreadystatechange = function () {                var parsed;                if (this.readyState === 4) {                    // Once the request comes back we need to parse it into a useable format (JSON)                    parsed = parseResponse(this.response);                    if (cb && typeof cb === 'function') {                        cb(parsed);                    }                }            };            request.open('GET', 'songs/Idol/Idol.sm');            request.send(null);        }        function loadAudio() {            var audio = new Howl({                preload: true,                src: ['songs/Idol/Idol.ogg']            });            _resources.audio = audio;        }        /*         * DON'T KNOW IF THIS IS THE BEST APPROACH BUT FEELS BETTER THAN WRITING AT RUNTIME         * The goal is to iterate over all the step measures and properly write them into a          * container with proper spacing. The only thing the run loop should be responsible for is          * checking if a button was pressed at the correct frame and scrolling the new container         * at the correct rate to match the BPM provided.         */        function setupSteps(stepFile) {            var stepContainer = _resources.stepContainer = new PIXI.DisplayObjectContainer();            stepContainer.y = _that.SCENE_HEIGHT + 75;            /*              * Iterate over every measure in the step file. Each measure contains 4 beats.             * Each beat can be broken up into 4th, 8th, 16th, 24th, 32nd, 48th, 64th, and 192nd notes.             */            stepFile.measures.forEach(function (measure, idx) {                // Determine number of potential (not every line will contain a note) notes in this measure.                var numNotes = measure.length,                    measureContainer = new PIXI.Container(),                    offsetNote = (_that.SCENE_HEIGHT - 75) / numNotes,                    currentOffsetY = 0;                measureContainer.x = (_that.SCENE_WIDTH - 500) / 2;                measureContainer.y = (_that.SCENE_HEIGHT - 75) * idx;                // Iterate over all notes in measure and create a note for each                measure.forEach(function (note, idx) {                    // There can be between 0 and 4 inputs for each note (left, down, up, right)                    // Turn note into array so its easier to work with                    var inputs = note.split('');                    inputs = inputs.splice(0, inputs.length - 1);                    setupReceptors(_loader, _loader.resources, measureContainer, inputs, false, currentOffsetY);                    currentOffsetY += offsetNote;                    stepContainer.addChild(measureContainer);                });            });        }        this.utils = {            // Converts passed in degree to equivalent radian            degressToRadians: function (deg) {                return deg * Math.PI / 180;            }        };        if (!elem) {            return;        }        this.SCENE_HEIGHT = elem.offsetHeight;        this.SCENE_WIDTH = elem.offsetWidth;        // Setup the stage and receptors        setup(function () {            // We need to request and parse the stepfile            loadStepFile(function (stepFile) {                loadAudio('songs/Idol/Idol.ogg');                setupSteps(stepFile);                _app.stage.addChild(_resources.stepContainer);                var firstTime = true;                // Listen for animate update                var currentTime = Date.now(),                    frameCount = 0;                stepFile.meta.DISPLAYBPM = +stepFile.meta.DISPLAYBPM.substring(0, stepFile.meta.DISPLAYBPM.length - 1);                _app.ticker.add(function(delta) {                    if (firstTime) {                        _resources.audio.play();                        firstTime = false;                    }                    _resources.stepContainer.y -= (_that.SCENE_HEIGHT + 93) / (stepFile.meta.DISPLAYBPM / 3);                });            });        });    };})(window);