import * as PIXI from 'pixi.js';import {audio} from './engine/engine.js';import {degreesToRadians} from './utils/math.js';const RECEPTOR_CONTAINER_WIDTH = 500;window.DDRJS = function (elem) {    var _that = this,        _resources = {            receptors: {}        },        _loader = new PIXI.loaders.Loader();    var _app;    var receptorContainer;    function loadAssets(assets, cb) {        assets.forEach(function (asset) {            _loader.add(asset.name, asset.path);        });        if (cb && typeof cb === 'function') {            _loader.once('complete', cb);        }        _loader.load();    }    // Once resources have loaded we need to setup each receptor add it to the stage    /*     * TODO: This needs to be abstracted more. This function is doing a lot of work     * for two separate use cases. This likely means the `receptor` specific logic should be removed     * and put in the calling function. This should be responsible for setting up rows of arrows     * regardless of where they're used     */    function setupReceptors(loader, resources, container, inputs, areReceptors, offsetY) {        var receptor = resources.receptor;        var texture,            receptorLeft,            receptorUp,            receptorDown,            receptorRight,            rotationsAtIdx = [0, 270, 90, 180];        if (!receptor) {            return;        }        texture = receptor.texture;        receptorContainer = container;        // Creates sprites for each receptor        if (+inputs[0]) {            receptorLeft = new PIXI.Sprite.from(texture);        }        if (+inputs[1]) {            receptorDown = new PIXI.Sprite.from(texture);        }        if (+inputs[2]) {            receptorUp = new PIXI.Sprite.from(texture);        }        if (+inputs[3]) {            receptorRight = new PIXI.Sprite.from(texture);        }        // Perform common setup for each receptor        [receptorLeft, receptorDown, receptorUp, receptorRight].forEach(function (receptor, idx) {            if (!receptor) {                return;            }            receptor.anchor.set(0.5);            receptor.x = (receptor.width + 25) * idx;            if (offsetY) {                receptor.y = offsetY;            }            receptor.rotation = degreesToRadians(rotationsAtIdx[idx]);        });        // This is disgusting...        if (areReceptors) {            _resources.receptors.receptorLeft = receptorLeft;            _resources.receptors.receptorUp = receptorUp;            _resources.receptors.receptorDown = receptorDown;            _resources.receptors.receptorRight = receptorRight;        }        // Add receptors to container        if (receptorLeft) {            receptorContainer.addChild(receptorLeft);        }        if (receptorDown) {            receptorContainer.addChild(receptorDown);        }        if (receptorUp) {            receptorContainer.addChild(receptorUp);        }        if (receptorRight) {            receptorContainer.addChild(receptorRight);        }    }    function setup (cb) {        _app = new PIXI.Application(_that.SCENE_WIDTH, _that.SCENE_HEIGHT, {            backgroundColor : '000000   '        });        // Create container to hold receptors        receptorContainer = new PIXI.Container();        receptorContainer.x = (_that.SCENE_WIDTH - RECEPTOR_CONTAINER_WIDTH) / 2;        receptorContainer.y = 75;        _resources.receptors.container = receptorContainer;        // Put the scene in the DOM        elem.appendChild(_app.view);        loadAssets([{            name: 'receptor',            path: 'assets/receptor.png'        }], function (loader, resources) {            setupReceptors(loader, resources, receptorContainer, [1, 1, 1, 1], true);            _app.stage.addChild(receptorContainer);            if (cb && typeof cb === 'function') {                cb();            }        });    }    function loadStepFile(cb) {        var request = new XMLHttpRequest();        function parseResponse(data) {            var formatted = {                meta: {},                measures: []            },            measure = [];            data.split('\n').forEach(function (row) {                var metaInfo;                // Don't do anything with an empty row                if (row === '' || row === '\n') {                    return;                }                // Any row that begins with a '#' is meta info                if (row.charAt(0) === '#') {                    // Strip unwanted characters                    row = row.substring(1, row.length - 1);                    // Separate the key/val                    metaInfo = row.split(':');                    formatted.meta[metaInfo[0]] = metaInfo[1] || '';                    return;                }                // Skip crap I don't understand                if (row === ',' || +row >= 0) {                    // If we get to this point we know we're going to be parsing the inputs                    // Split measures on commas                    if (row !== ',') {                        measure.push(row);                        return;                    }                    // If this row === ',' we want to push the current measure into the formatted array                    // and reset the current measure.                    formatted.measures.push(measure);                    measure = [];                }            });            return formatted;        }        request.onreadystatechange = function () {            var parsed;            if (this.readyState === 4) {                // Once the request comes back we need to parse it into a useable format (JSON)                parsed = parseResponse(this.response);                if (cb && typeof cb === 'function') {                    cb(parsed);                }            }        };        request.open('GET', 'songs/Idol/Idol.sm');        request.send(null);    }    /*     * DON'T KNOW IF THIS IS THE BEST APPROACH BUT FEELS BETTER THAN WRITING AT RUNTIME     * The goal is to iterate over all the step measures and properly write them into a      * container with proper spacing. The only thing the run loop should be responsible for is      * checking if a button was pressed at the correct frame and scrolling the new container     * at the correct rate to match the BPM provided.     */    function setupSteps(stepFile) {        var stepContainer = _resources.stepContainer = new PIXI.DisplayObjectContainer();        stepContainer.y = 75;        /*          * Iterate over every measure in the step file. Each measure contains 4 beats.         * Each beat can be broken up into 4th, 8th, 16th, 24th, 32nd, 48th, 64th, and 192nd notes.         */        stepFile.measures.forEach(function (measure, idx) {            // Determine number of potential (not every line will contain a note) notes in this measure.            var numNotes = measure.length,                measureContainer = new PIXI.Container(),                offsetNote = (_that.SCENE_HEIGHT) / numNotes,                currentOffsetY = 0;            measureContainer.x = (_that.SCENE_WIDTH - 500) / 2;            measureContainer.y = (_that.SCENE_HEIGHT) * idx;            // Iterate over all notes in measure and create a note for each            measure.forEach(function (note, idx) {                // There can be between 0 and 4 inputs for each note (left, down, up, right)                // Turn note into array so its easier to work with                var inputs = note.split('');                setupReceptors(_loader, _loader.resources, measureContainer, inputs, false, currentOffsetY);                currentOffsetY += offsetNote;                stepContainer.addChild(measureContainer);            });        });    }    if (!elem) {        return;    }    this.SCENE_HEIGHT = elem.offsetHeight;    this.SCENE_WIDTH = elem.offsetWidth;    // Setup the stage and receptors    setup(function () {        // We need to request and parse the stepfile        loadStepFile(function (stepFile) {            _resources.audio = audio.load('songs/Idol/Idol.ogg');            setupSteps(stepFile);            _app.stage.addChild(_resources.stepContainer);            var firstTime = true,                isPlaying = false;            stepFile.meta.DISPLAYBPM = +stepFile.meta.DISPLAYBPM.substring(0, stepFile.meta.DISPLAYBPM.length - 1);            _app.ticker.speed = (_that.SCENE_HEIGHT - 75) / (stepFile.meta.DISPLAYBPM / 3);            _app.ticker.add(function(delta) {                if (firstTime) {                    // Wait until the audio starts playing begin animating the note stream                    _resources.audio.once('play', function () {                        isPlaying = true;                    });                    _resources.audio.play();                    firstTime = false;                }                if (!isPlaying) {                    return;                }                _resources.stepContainer.y -= delta;            });        });    });};